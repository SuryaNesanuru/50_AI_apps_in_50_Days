<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Recipe Assistant</title>
    <!-- We'll use Tailwind CSS for quick, modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        /* Simple spinner animation */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #f97316; /* Orange color */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Hide element by default */
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white w-full max-w-2xl p-6 sm:p-8 rounded-2xl shadow-lg">

        <!-- Header -->
        <div class="text-center">
            <h1 class="text-3xl font-bold text-gray-900">üßë‚Äçüç≥ AI Recipe Assistant</h1>
            <p class="mt-2 text-lg text-gray-600">What do you want to cook today?</p>
        </div>

        <!-- Prompt Input -->
        <div class="mt-6">
            <label for="prompt-input" class="block text-sm font-medium text-gray-700">Recipe Request:</label>
            <input id="prompt-input" type="text" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-orange-500 focus:ring-orange-500 sm:text-sm p-3" placeholder="e.g., Quick and easy chicken pasta">
        </div>

        <!-- Generate Button -->
        <button id="generate-button" class="mt-6 w-full flex items-center justify-center gap-2 rounded-lg bg-orange-600 px-4 py-3 text-lg font-semibold text-white shadow-sm transition-all hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 disabled:bg-orange-300">
            <!-- Spinner (hidden by default) -->
            <div id="spinner" class="spinner hidden"></div>
            <!-- Button Text -->
            <span id="button-text">Find Recipe</span>
        </button>
        
        <!-- Error Message -->
        <div id="error-box" class="mt-4 p-3 bg-red-100 border border-red-300 text-red-700 rounded-lg hidden">
            <!-- Error messages will appear here -->
        </div>

        <!-- Result Area -->
        <div id="result-container" class="mt-6 hidden">
            <!-- Formatted Recipe Card -->
            <div class="border border-gray-200 rounded-lg overflow-hidden">
                <!-- Recipe Title -->
                <div class="p-4 bg-gray-50 border-b border-gray-200">
                    <h2 id="recipe-title" class="text-2xl font-bold text-gray-900"></h2>
                </div>

                <!-- Recipe Body -->
                <div class="p-4 sm:p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Ingredients -->
                    <div class="md:col-span-1">
                        <h3 class="text-lg font-semibold text-gray-800">Ingredients:</h3>
                        <ul id="recipe-ingredients" class="mt-2 list-disc list-inside text-gray-700 space-y-1">
                            <!-- Ingredients will be injected here -->
                        </ul>
                    </div>
                    <!-- Instructions -->
                    <div class="md:col-span-2">
                        <div class="flex justify-between items-center">
                            <h3 class="text-lg font-semibold text-gray-800">Instructions:</h3>
                            <!-- TTS Button -->
                            <button id="tts-button" title="Read Aloud" class="flex items-center gap-1.5 text-sm text-orange-600 hover:text-orange-800 disabled:text-gray-400">
                                <svg id="tts-icon-play" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                                <svg id="tts-icon-loading" class="spinner h-5 w-5 text-orange-600 hidden" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span id="tts-button-text">Read Aloud</span>
                            </button>
                        </div>
                        <ol id="recipe-instructions" class="mt-2 list-decimal list-inside text-gray-700 space-y-2">
                            <!-- Instructions will be injected here -->
                        </ol>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden Audio Player -->
        <audio id="audio-player" class="hidden"></audio>

    </div>

    <script>
        // --- DOM Elements ---
        const promptInput = document.getElementById('prompt-input');
        const generateButton = document.getElementById('generate-button');
        const spinner = document.getElementById('spinner');
        const buttonText = document.getElementById('button-text');
        const resultContainer = document.getElementById('result-container');
        const errorBox = document.getElementById('error-box');
        
        // Recipe Card Elements
        const recipeTitle = document.getElementById('recipe-title');
        const recipeIngredients = document.getElementById('recipe-ingredients');
        const recipeInstructions = document.getElementById('recipe-instructions');
        
        // TTS Elements
        const ttsButton = document.getElementById('tts-button');
        const ttsIconPlay = document.getElementById('tts-icon-play');
        const ttsIconLoading = document.getElementById('tts-icon-loading');
        const ttsButtonText = document.getElementById('tts-button-text');
        const audioPlayer = document.getElementById('audio-player');

        // --- API Configuration ---
        const apiKey = ""; // Leave blank, environment will provide it
        const recipeApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

        // --- App State ---
        let recipeInstructionsText = ""; // To store the plain text for TTS
        let currentAudioUrl = null; // To store the playable audio URL

        // --- Event Listeners ---
        generateButton.addEventListener('click', handleRecipeGenerate);
        ttsButton.addEventListener('click', handleTtsGenerate);

        // --- Recipe Schema ---
        // This is the key to getting structured JSON
        const recipeSchema = {
            type: "OBJECT",
            properties: {
                "title": { "type": "STRING" },
                "ingredients": {
                    "type": "ARRAY",
                    "items": { "type": "STRING" }
                },
                "instructions": {
                    "type": "ARRAY",
                    "items": { "type": "STRING" }
                }
            },
            required: ["title", "ingredients", "instructions"]
        };

        // --- Main Functions ---

        async function handleRecipeGenerate() {
            const userQuery = promptInput.value;
            if (userQuery.trim() === "") {
                showError("Please enter a recipe request.");
                return;
            }

            setLoading(true);

            // 1. Construct the API Payload for JSON
            const payload = {
                contents: [{
                    parts: [{ "text": `Find a recipe for: ${userQuery}.` }]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: recipeSchema
                }
            };

            // 2. Make API Call
            try {
                const response = await fetchWithRetry(recipeApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = response.candidates?.[0];
                const jsonText = candidate?.content?.parts?.[0]?.text;

                if (!jsonText) {
                    throw new Error("Invalid JSON response from API.");
                }

                // 3. Parse and Display Result
                const recipe = JSON.parse(jsonText);
                displayRecipe(recipe);

            } catch (error) {
                console.error('Error generating content:', error);
                showError(`Failed to get recipe. Error: ${error.message}`);
            } finally {
                setLoading(false);
            }
        }

        async function handleTtsGenerate() {
            if (!recipeInstructionsText) return;
            
            // If we already have audio, just play it
            if (currentAudioUrl) {
                audioPlayer.src = currentAudioUrl;
                audioPlayer.play();
                return;
            }

            setTtsLoading(true);
            
            // 1. Construct TTS Payload
            const payload = {
                contents: [{
                    parts: [{ text: `Say with a friendly and clear voice: ${recipeInstructionsText}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" } // A friendly, firm voice
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            // 2. Make API Call
            try {
                const response = await fetchWithRetry(ttsApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const part = response?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data; // Base64 PCM data
                const mimeType = part?.inlineData?.mimeType; // e.g., "audio/L16;rate=24000"

                if (!audioData || !mimeType) {
                    throw new Error("Invalid audio response from API.");
                }

                // 3. Convert and Play Audio
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                currentAudioUrl = URL.createObjectURL(wavBlob);
                audioPlayer.src = currentAudioUrl;
                audioPlayer.play();

            } catch (error) {
                console.error('Error generating speech:', error);
                showError(`Failed to generate audio. Error: ${error.message}`);
            } finally {
                setTtsLoading(false);
            }
        }

        // --- API Fetch Utility ---
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API Error (${response.status}): ${errorData.error?.message || response.statusText}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.warn(`Attempt ${i + 1} failed: ${error.message}`);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    } else {
                        throw error;
                    }
                }
            }
        }

        // --- Audio Conversion Utilities ---

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const blockAlign = (numChannels * bitsPerSample) / 8;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            // 'fmt ' sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // Audio format (1 = PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            // 'data' sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write PCM data
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- UI Helper Functions ---

        function setLoading(isLoading) {
            generateButton.disabled = isLoading;
            spinner.classList.toggle('hidden', !isLoading);
            buttonText.textContent = isLoading ? 'Finding...' : 'Find Recipe';
            errorBox.classList.add('hidden');
            if(isLoading) resultContainer.classList.add('hidden');
        }

        function setTtsLoading(isLoading) {
            ttsButton.disabled = isLoading;
            ttsIconPlay.classList.toggle('hidden', isLoading);
            ttsIconLoading.classList.toggle('hidden', !isLoading);
            ttsButtonText.textContent = isLoading ? 'Generating...' : 'Read Aloud';
        }

        function displayRecipe(recipe) {
            // Reset audio
            if (currentAudioUrl) {
                URL.revokeObjectURL(currentAudioUrl);
                currentAudioUrl = null;
            }
            audioPlayer.src = "";

            // Populate text fields
            recipeTitle.textContent = recipe.title || "Untitled Recipe";
            
            // Populate ingredients
            recipeIngredients.innerHTML = ""; // Clear old list
            if (recipe.ingredients && recipe.ingredients.length > 0) {
                recipe.ingredients.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    recipeIngredients.appendChild(li);
                });
            } else {
                recipeIngredients.innerHTML = "<li>No ingredients listed.</li>";
            }

            // Populate instructions
            recipeInstructions.innerHTML = ""; // Clear old list
            recipeInstructionsText = ""; // Clear text for TTS
            if (recipe.instructions && recipe.instructions.length > 0) {
                recipe.instructions.forEach((step, index) => {
                    const li = document.createElement('li');
                    li.textContent = step;
                    recipeInstructions.appendChild(li);
                    recipeInstructionsText += `Step ${index + 1}: ${step}. `; // Build plain text for TTS
                });
            } else {
                recipeInstructions.innerHTML = "<li>No instructions provided.</li>";
            }

            resultContainer.classList.remove('hidden');
            errorBox.classList.add('hidden');
        }

        function showError(message) {
            errorBox.textContent = message;
            errorBox.classList.remove('hidden');
            resultContainer.classList.add('hidden');
        }

    </script>
</body>
</html>